<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨æ–‡åˆ†ç±»å®éªŒå®¤</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --card-bg: #161b22;
            --border-color: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent: #58a6ff;
            --success: #238636;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 800px;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .input-group {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 24px;
        }

        textarea {
            width: 100%;
            height: 120px;
            background: #0d1117;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 12px;
        }

        button {
            background-color: var(--success);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            opacity: 0.9;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .result-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .preview-img {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            background: #2a3038;
            cursor: pointer;
            flex-shrink: 0;
        }

        .content {
            flex: 1;
            min-width: 0;
        }

        .tweet-text {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-clamp: 2;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tags-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tag {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent);
            border: 1px solid rgba(88, 166, 255, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .tag.photography {
            color: #f2cc60;
            background: rgba(242, 204, 96, 0.15);
            border-color: rgba(242, 204, 96, 0.3);
        }

        .tag.tech {
            color: #58a6ff;
        }

        .tag.art {
            color: #f778ba;
            background: rgba(247, 120, 186, 0.15);
            border-color: rgba(247, 120, 186, 0.3);
        }

        .rule-info {
            font-size: 11px;
            color: #6e7681;
            margin-left: 8px;
        }

        .error {
            color: #ff7b72;
            font-size: 13px;
        }

        .loading {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Rule Explainer */
        .rules-explainer {
            margin-top: 12px;
            font-size: 12px;
            color: var(--text-secondary);
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ› ï¸ æ¨æ–‡åˆ†ç±»å®éªŒå®¤ (Tweet Lab)</h1>

        <div class="input-group">
            <textarea id="urlInput" placeholder="åœ¨æ­¤ç²˜è´´æ¨æ–‡é“¾æ¥ (æ¯è¡Œä¸€ä¸ª)...
ç¤ºä¾‹:
https://x.com/username/status/123456
https://x.com/photographer/status/987654"></textarea>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:8px;">
                <button id="analyzeBtn">è¿è¡Œåˆ†æ</button>
                <span id="status" style="font-size:13px; color:var(--text-secondary);"></span>
            </div>
        </div>
    </div>

    <!-- AI Configuration Panel -->
    <div class="input-group" id="aiConfigPanel">
        <details>
            <summary style="cursor:pointer; font-weight:600; margin-bottom:12px;">ğŸ¤– AI è¯†åˆ«é…ç½® (å¯é€‰)</summary>
            <div style="display:flex; flex-direction:column; gap:12px; margin-top:12px;">
                <div>
                    <label style="font-size:12px; color:var(--text-secondary);">API Endpoint</label>
                    <input type="text" id="aiApiEndpoint" placeholder="https://api.z.ai/api/coding/paas/v4"
                        style="width:100%; padding:8px; background:#0d1117; border:1px solid var(--border-color); color:var(--text-primary); border-radius:4px; box-sizing:border-box;">
                </div>
                <div>
                    <label style="font-size:12px; color:var(--text-secondary);">API Key</label>
                    <input type="password" id="aiApiKey" placeholder="your-api-key-here"
                        style="width:100%; padding:8px; background:#0d1117; border:1px solid var(--border-color); color:var(--text-primary); border-radius:4px; box-sizing:border-box;">
                </div>
                <div>
                    <label style="font-size:12px; color:var(--text-secondary);">æ¨¡å‹</label>
                    <select id="aiModel"
                        style="width:100%; padding:8px; background:#0d1117; border:1px solid var(--border-color); color:var(--text-primary); border-radius:4px;">
                        <option value="glm-4.5-air">GLM-4.5-Air (131K, æ¨è)</option>
                        <option value="glm-4.5">GLM-4.5 (131K)</option>
                        <option value="glm-4.6">GLM-4.6 (205K)</option>
                        <option value="glm-4.7">GLM-4.7 (205K, æœ€æ–°)</option>
                    </select>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <label style="display:flex; align-items:center; gap:4px; font-size:13px; cursor:pointer;">
                        <input type="checkbox" id="enableAiClassification">
                        å¯ç”¨ AI äºŒæ¬¡è¯†åˆ«
                    </label>
                    <button id="saveAiConfigBtn"
                        style="margin-left:auto; padding:6px 12px; font-size:12px;">ä¿å­˜é…ç½®</button>
                </div>
                <div id="aiConfigStatus" style="font-size:11px; color:var(--text-secondary);"></div>
            </div>
        </details>
    </div>

    <div id="resultsList" class="results"></div>
    </div>

    <script>
        // ================= LOGIC =================

        const urlInput = document.getElementById('urlInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const resultsList = document.getElementById('resultsList');
        const statusSpan = document.getElementById('status');

        // Find local API Base
        let apiBase = window.location.origin;

        // If protocol is file, use the default port (5502 as per user config change)
        if (window.location.protocol === 'file:') {
            apiBase = 'http://localhost:5502';
        }
        // Otherwise, use relative path (works for 5502, 5500, or any port correctly serving the backend)

        console.log('Using API Base:', apiBase);

        // ================= AI CONFIG: localStorage persistence =================
        const AI_CONFIG_KEY = 'tweetlab_ai_config';

        const aiApiEndpoint = document.getElementById('aiApiEndpoint');
        const aiApiKey = document.getElementById('aiApiKey');
        const aiModel = document.getElementById('aiModel');
        const enableAiCheckbox = document.getElementById('enableAiClassification');
        const saveAiConfigBtn = document.getElementById('saveAiConfigBtn');
        const aiConfigStatus = document.getElementById('aiConfigStatus');

        // Load saved config on page load
        function loadAiConfig() {
            try {
                const saved = localStorage.getItem(AI_CONFIG_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    aiApiEndpoint.value = config.endpoint || '';
                    aiApiKey.value = config.apiKey || '';
                    aiModel.value = config.model || 'glm-4.5-air';
                    enableAiCheckbox.checked = config.enabled || false;
                    aiConfigStatus.textContent = 'âœ“ å·²åŠ è½½ä¿å­˜çš„é…ç½®';
                }
            } catch (e) {
                console.error('Failed to load AI config:', e);
            }
        }

        // Save config to localStorage
        function saveAiConfig() {
            try {
                const config = {
                    endpoint: aiApiEndpoint.value,
                    apiKey: aiApiKey.value,
                    model: aiModel.value,
                    enabled: enableAiCheckbox.checked
                };
                localStorage.setItem(AI_CONFIG_KEY, JSON.stringify(config));
                aiConfigStatus.textContent = 'âœ“ é…ç½®å·²ä¿å­˜';
                setTimeout(() => aiConfigStatus.textContent = '', 3000);
            } catch (e) {
                console.error('Failed to save AI config:', e);
                aiConfigStatus.textContent = 'âŒ ä¿å­˜å¤±è´¥';
            }
        }

        saveAiConfigBtn.addEventListener('click', saveAiConfig);
        loadAiConfig(); // Load on page init

        // ================= URL INPUT: localStorage persistence =================
        const URL_INPUT_KEY = 'tweetlab_url_input';

        // Load saved URLs on page load
        const savedUrls = localStorage.getItem(URL_INPUT_KEY);
        if (savedUrls) {
            urlInput.value = savedUrls;
        }

        // Auto-save URLs on change
        urlInput.addEventListener('input', () => {
            localStorage.setItem(URL_INPUT_KEY, urlInput.value);
        });

        analyzeBtn.addEventListener('click', async () => {
            const text = urlInput.value.trim();
            if (!text) return;

            const urls = text.split('\n')
                .map(l => l.trim())
                .filter(l => l && (l.includes('x.com') || l.includes('twitter.com')));

            resultsList.innerHTML = '';
            analyzeBtn.disabled = true;
            statusSpan.textContent = `æ­£åœ¨å¤„ç† ${urls.length} æ¡æ¨æ–‡...`;

            for (const url of urls) {
                await processTweet(url);
            }

            analyzeBtn.disabled = false;
            statusSpan.textContent = 'å®Œæˆ!';
        });

        async function processTweet(url) {
            // UI Placeholder
            const card = document.createElement('div');
            card.className = 'result-card';
            card.innerHTML = `
                <div class="loading">æ­£åœ¨è·å–æ•°æ®: ${url.slice(0, 40)}...</div>
            `;
            resultsList.appendChild(card);

            try {
                const tweetId = extractTweetId(url);
                if (!tweetId) throw new Error("æ— æ•ˆçš„é“¾æ¥ (æœªæ‰¾åˆ°æ¨æ–‡ ID)");

                // Fetch Data
                // Use absolute path to ensure it hits the server if we are on localhost
                const fetchUrl = `${apiBase}/api/tweet_info?id=${tweetId}`;
                console.log('Fetching:', fetchUrl);

                const res = await fetch(fetchUrl);
                if (!res.ok) {
                    const errorText = await res.text().catch(() => '');
                    throw new Error(`API å“åº”å¤±è´¥ (${res.status}): ${errorText.slice(0, 50) || 'è¯·ç¡®è®¤åç«¯æœåŠ¡å·²å¯åŠ¨'}`);
                }
                const data = await res.json();

                if (data.error) throw new Error(`API é”™è¯¯: ${data.error}`);

                // Store data on card for AI analysis
                card._tweetData = data;

                // Render Result (AI-only mode)
                renderResult(card, url, data, null);

            } catch (e) {
                console.error(e);
                card.innerHTML = `
                    <div style="flex:1">
                        <div class="error">âŒ é”™è¯¯: ${e.message}</div>
                        <div style="font-size:11px; color:#6e7681; margin-top:4px;">
                            è¯·ç¡®è®¤ <b>server.py</b> æ­£åœ¨è¿è¡Œã€‚<br>
                            å¦‚æœä»æœ‰é—®é¢˜ï¼Œè¯·å°è¯•ç›´æ¥åœ¨æµè§ˆå™¨è®¿é—®: <br>
                            <a href="http://localhost:5502/test_classification.html" target="_blank" style="color:#58a6ff">http://localhost:5502/test_classification.html</a>
                        </div>
                    </div>
                `;
            }
        }

        function extractTweetId(url) {
            const match = url.match(/status\/(\d+)/);
            return match ? match[1] : null;
        }

        // AI Classification via GLM API
        async function runAiClassification(text, endpoint, apiKey, model) {
            // Ensure endpoint ends with /chat/completions (OpenAI-compatible format)
            let fullEndpoint = endpoint.replace(/\/+$/, ''); // Remove trailing slashes
            if (!fullEndpoint.endsWith('/chat/completions')) {
                fullEndpoint += '/chat/completions';
            }

            const taxonomy = {
                "äººç‰©è‚–åƒ": ["åäºº/ç°å®ä¸»ä¹‰", "æ€§æ„Ÿ/æ—¶å°š", "è‡ªå®šä¹‰è§’è‰²", "ä¸ªäººå“ç‰Œ", "èº«ä»½ç¼–è¾‘", "å·¥ä½œå®¤è‚–åƒ"],
                "è‰ºæœ¯ä¸å¹»æƒ³": ["åŠ¨æ¼«/Kawaii", "å¡é€š/æ’å›¾", "ç§‘å¹»/è¶…ç°å®", "Chibié£æ ¼", "ä¿¡æ¯å›¾/Infographic", "æŠ½è±¡/å®éªŒ"],
                "äº§å“ä¸è¥é”€": ["äº§å“æ‘„å½±", "å¹¿å‘Š/æµ·æŠ¥", "åŒ…è£…è®¾è®¡", "æ—¶å°šå“ç‰Œ", "å¥¢åæŠ¤è‚¤", "é£Ÿç‰©å¹¿å‘Š", "æˆåˆ†å¯è§†åŒ–", "å°çº¢ä¹¦é£æ ¼"],
                "å¯è§†åŒ–ä¸åˆ†è§£": ["æˆåˆ†ç¯ç»•", "æˆåˆ†æ‚¬æµ®", "æµ®åŠ¨æ„å›¾", "è§£å‰–/ç”Ÿç‰©", "æ•™è‚²å›¾è¡¨"],
                "å¹½é»˜ä¸Meme": ["æ”¿æ²»/è®½åˆº", "æ··åˆ/ç¼–è¾‘", "æç¬‘åœºæ™¯"],
                "è‡ªç„¶ä¸ç¯å¢ƒ": ["å­£èŠ‚/æ™¯è§‚", "åŸå¸‚/æ°›å›´", "æ²»æ„ˆ/æ¢¦å¹»", "åœ°å›¾/3Dè§†å›¾"],
                "è§†é¢‘ä¸åŠ¨æ€": ["æ–‡æœ¬åˆ°è§†é¢‘", "åŠ¨ç”»æ•ˆæœ", "äº§å“æ—‹è½¬"],
                "å…¶ä»–/å®éªŒ": ["ä¼¦ç†/äº‰è®®", "å·¥å…·æ¯”è¾ƒ"]
            };

            const systemPrompt = `ä½ æ˜¯AIç”Ÿå›¾æç¤ºè¯åˆ†ç±»å™¨ã€‚åªè¿”å›JSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

æ ¹æ®æ¨æ–‡å†…å®¹ï¼Œä½¿ç”¨ä»¥ä¸‹åˆ†ç±»ä½“ç³»è¿›è¡Œæ ‡æ³¨ï¼š

ã€åˆ†ç±»ä½“ç³»ã€‘
${JSON.stringify(taxonomy, null, 2)}

ã€è¾“å‡ºè¦æ±‚ã€‘
1. hierarchicalï¼šé€‰æ‹©1-2ä¸ªä¸€çº§å¤§ç±»ï¼Œæ¯ä¸ªå¤§ç±»ä¸‹é€‰æ‹©1-3ä¸ªæœ€ç›¸å…³çš„äºŒçº§å­ç±»
2. flat_tagsï¼šæå–3-5ä¸ªæè¿°æ€§å…³é”®è¯ï¼ˆé£æ ¼ã€æŠ€æœ¯ã€æ°›å›´ç­‰ï¼‰

ã€è¾“å‡ºæ ¼å¼ã€‘
{
  "hierarchical": {
    "ä¸€çº§å¤§ç±»": ["äºŒçº§å­ç±»1", "äºŒçº§å­ç±»2"]
  },
  "flat_tags": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"]
}`;

            const response = await fetch(fullEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: text || '(ç©ºå†…å®¹)' }
                    ],
                    temperature: 0.3,
                    max_tokens: 500
                })
            });

            if (!response.ok) {
                const errText = await response.text().catch(() => '');
                throw new Error(`AI API ${response.status}: ${errText.slice(0, 50)}`);
            }

            const result = await response.json();
            console.log('ğŸ¤– AI API å®Œæ•´å“åº”:', result);

            // GLM models might return content in different fields
            const message = result.choices?.[0]?.message || {};
            let content = message.content || '';
            const reasoning = message.reasoning_content || '';

            console.log('ğŸ¤– content:', content);
            console.log('ğŸ¤– reasoning_content:', reasoning);

            // Use content if available, otherwise try to extract from reasoning
            let textToAnalyze = content || reasoning;

            // Try to extract JSON from the text - look for hierarchical or tags format
            // Match JSON object containing either hierarchical or tags
            const jsonMatch = textToAnalyze.match(/\{[\s\S]*?"(hierarchical|tags)"[\s\S]*?\}/);
            if (jsonMatch) {
                try {
                    // Find the complete JSON object
                    let jsonStr = jsonMatch[0];
                    // Try to find a balanced JSON by counting braces
                    let braceCount = 0;
                    let startIdx = textToAnalyze.indexOf('{');
                    for (let i = startIdx; i < textToAnalyze.length; i++) {
                        if (textToAnalyze[i] === '{') braceCount++;
                        if (textToAnalyze[i] === '}') braceCount--;
                        if (braceCount === 0) {
                            jsonStr = textToAnalyze.slice(startIdx, i + 1);
                            break;
                        }
                    }

                    const parsed = JSON.parse(jsonStr);
                    console.log('ğŸ¤– æå–åˆ°çš„JSON:', jsonStr);
                    console.log('ğŸ¤– è§£æåçš„æ•°æ®:', parsed);

                    // Handle new hierarchical + flat_tags format
                    const result = [];

                    if (parsed.hierarchical) {
                        // Extract hierarchical categories
                        for (const [level1, level2List] of Object.entries(parsed.hierarchical)) {
                            result.push({ label: `ğŸ“‚ ${level1}`, reason: 'ä¸€çº§åˆ†ç±»', type: 'ai-category' });
                            if (Array.isArray(level2List)) {
                                level2List.forEach(sub => {
                                    result.push({ label: sub, reason: level1, type: 'ai-subcategory' });
                                });
                            }
                        }
                    }

                    if (parsed.flat_tags && Array.isArray(parsed.flat_tags)) {
                        parsed.flat_tags.forEach(tag => {
                            result.push({ label: `ğŸ·ï¸ ${tag}`, reason: 'æè¿°æ ‡ç­¾', type: 'ai-tag' });
                        });
                    }

                    // Fallback to old tags format
                    if (parsed.tags && Array.isArray(parsed.tags)) {
                        parsed.tags.forEach(tag => {
                            result.push({ label: tag, reason: 'AIåˆ†æ', type: 'ai' });
                        });
                    }

                    if (result.length > 0) return result;
                } catch (e) {
                    console.log('ğŸ¤– JSONè§£æå¤±è´¥:', e);
                }
            }

            // Fallback: extract categories from text directly
            console.log('ğŸ¤– æœªæ‰¾åˆ°JSONï¼Œå°è¯•ä»æ–‡æœ¬æå–æ ‡ç­¾');
            const categories = ['äººç‰©è‚–åƒ', 'è‰ºæœ¯ä¸å¹»æƒ³', 'äº§å“ä¸è¥é”€', 'å¯è§†åŒ–ä¸åˆ†è§£', 'å¹½é»˜ä¸Meme', 'è‡ªç„¶ä¸ç¯å¢ƒ', 'è§†é¢‘ä¸åŠ¨æ€', 'å…¶ä»–/å®éªŒ'];
            const foundTags = categories.filter(tag => textToAnalyze.includes(tag));

            if (foundTags.length > 0) {
                console.log('ğŸ¤– ä»æ–‡æœ¬æå–çš„æ ‡ç­¾:', foundTags);
                return foundTags.map(tag => ({ label: tag, reason: 'ä»åˆ†ææå–', type: 'ai' }));
            }

            // Still nothing? Return a summary
            return [{ label: '(AIæœªè¿”å›æ ‡ç­¾)', reason: 'è¯·æ£€æŸ¥æ§åˆ¶å°', type: 'ai' }];
        }

        function renderResult(card, url, data, aiTags) {
            // Note: vxtwitter API returns 'mediaURLs' (camelCase)
            // Only show first thumbnail for compact view
            const firstImg = (data.mediaURLs || [])[0];
            const mediaHtml = firstImg
                ? `<img src="${firstImg}" class="preview-img" onclick="window.open('${firstImg}','_blank')" title="ç‚¹å‡»æŸ¥çœ‹å¤§å›¾">`
                : '';

            const cleanText = data.text || '';

            // AI section: always show button + result area
            const aiTagsHtml = aiTags ? aiTags.map(tag => `
                <span class="tag ai" style="background:rgba(139,92,246,0.15); color:#a78bfa; border-color:rgba(139,92,246,0.3);">
                    ${tag.label}
                </span>
            `).join('') : '';

            const aiSectionHtml = `
                <span class="ai-result">${aiTagsHtml}</span>
                <button class="ai-analyze-btn" style="padding:4px 10px; font-size:11px; background:#7c3aed; border-radius:4px; margin-left:8px;">
                    ğŸ”„ AIåˆ†æ
                </button>
                <span class="ai-loading" style="display:none; font-size:11px; color:#a78bfa; margin-left:8px;">åˆ†æä¸­...</span>
            `;

            card.innerHTML = `
                ${mediaHtml}
                <div class="content">
                    <div class="tweet-text">${cleanText}</div>
                    <div class="ai-row">
                        <span style="font-size:11px; color:#6e7681; margin-right:8px;">ğŸ¤– åˆ†ç±»:</span>
                        ${aiSectionHtml}
                    </div>
                </div>
            `;

            // Attach AI button handler
            const aiBtn = card.querySelector('.ai-analyze-btn');
            if (aiBtn) {
                aiBtn.addEventListener('click', () => triggerAiClassification(card));
            }
        }

        // AI Classification (triggered by button click)
        async function triggerAiClassification(card) {
            const btn = card.querySelector('.ai-analyze-btn');
            const loading = card.querySelector('.ai-loading');
            const resultSpan = card.querySelector('.ai-result');

            if (!aiApiKey.value || !aiApiEndpoint.value) {
                resultSpan.innerHTML = '<span style="color:#ff7b72; font-size:11px;">è¯·å…ˆé…ç½® API</span>';
                return;
            }

            btn.style.display = 'none';
            loading.style.display = 'inline';

            try {
                const text = card._tweetData?.text || '';
                const aiTags = await runAiClassification(text, aiApiEndpoint.value, aiApiKey.value, aiModel.value);

                loading.style.display = 'none';
                btn.style.display = 'inline';
                resultSpan.innerHTML = aiTags.map(tag => `
                    <span class="tag ai" style="background:rgba(139,92,246,0.15); color:#a78bfa; border-color:rgba(139,92,246,0.3);">
                        ğŸ¤– ${tag.label}
                    </span>
                `).join('');
            } catch (err) {
                loading.style.display = 'none';
                btn.style.display = 'inline';
                resultSpan.innerHTML = `<span style="color:#ff7b72; font-size:11px;">é”™è¯¯: ${err.message.slice(0, 30)}</span>`;
            }
        }
    </script>
</body>

</html>